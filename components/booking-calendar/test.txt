UI Plan & Logic for Stacked Bars Calendar

Context: Booking calendar for interpreters. Multiple bookings can overlap at the same time (different interpreters). We will show thin bars stacked in up to 2 lanes per time cell. Row height is fixed (e.g., 60px). We keep ScrollArea + react-virtual behavior as-is.

⸻

1) Goals (simple)
	•	Allow multiple bookings at the same time for the same day (e.g., 2 interpreters).
	•	Visual: thin bars placed over the grid cells (overlay). No text inside bars.
	•	MAX_LANES = 2 (constant for now). If a cell already has 2 bars, that cell becomes not clickable for new bookings.
	•	Keep current virtual scroll (fixed row height).

⸻

2) Constraints
	•	Row height fixed: 60px (configurable). No dynamic row height.
	•	Only 2 lanes (0 and 1).
	•	Bars are overlay above cells (absolute positioning). Background grid still visible and clickable when capacity allows.
	•	Time handling: keep current behavior for now (no UTC/Local refactor). A future task can align all to Local.

⸻

3) Glossary
	•	timeSlots: array of slot labels for the day (e.g., [“08:00”,“08:30”,…]).
	•	cell: one time slot cell in a day row.
	•	bar: a thin rectangle representing a single booking spanning multiple consecutive cells.
	•	lane: vertical layer for overlapping bars (0 or 1).
	•	occupancy: number of bars occupying a specific cell index (0–2).

⸻

4) Visual Layout (per day row)
	•	Grid structure per row (unchanged): grid-template-columns: 120px repeat(N, 120px)
	•	Column 1 (120px): day label (sticky).
	•	Columns 2..(N+1): time cells.
	•	Two layers inside each row container:
	1.	Background Grid Layer (for time cells): receives clicks to create booking if capacity allows.
	2.	Bars Overlay Layer (absolute positioned): renders thin bars for that day.

Bar size/position:
	•	Height: 10–14px (config BAR_HEIGHT).
	•	Vertical position: top = LANE_TOP_OFFSET + lane * BAR_STACK_GAP (e.g., top: 8px for lane 0, top: 28px for lane 1 inside the 60px row).
	•	Horizontal position/width (two options):
	•	Option A (absolute pixels): left = DAY_LABEL_WIDTH + startIndex * CELL_WIDTH, width = (endIndex - startIndex) * CELL_WIDTH.
	•	Option B (CSS grid placement): if overlay participates in the grid, set gridColumn: (startIndex + 2) / (endIndex + 2) and place bars with align-self: start; position: relative; top: …. (Option A is simpler when using a separate absolute overlay.)

⸻

5) Data Structures (Types)

// constants.ts
export const MAX_LANES = 2;              // lanes: 0, 1
export const ROW_HEIGHT = 60;            // px
export const CELL_WIDTH = 120;           // px (must match grid)
export const DAY_LABEL_WIDTH = 120;      // px (first column)
export const BAR_HEIGHT = 12;            // px
export const LANE_TOP_OFFSET = 8;        // px (padding from top of row)
export const BAR_STACK_GAP = 20;         // px (distance between lanes)

// types/booking.ts (additions)
export type BarItem = {
  bookingId: number;
  name: string;      // optional for tooltip
  room: string;      // optional for tooltip
  status: string;    // affects color
  startIndex: number;  // inclusive
  endIndex: number;    // exclusive
  lane: 0 | 1;         // stacked level
};

export type DayBars = {
  bars: BarItem[];
  occupancy: number[]; // length === timeSlots.length, values 0..MAX_LANES
};


⸻

6) Component Responsibilities

BookingCalendar.tsx (top level)
	•	Owns currentDate, selectedSlot, open/close of BookingForm.
	•	Builds timeSlots, daysInMonth (same as now).
	•	Uses useBookings(currentDate) to fetch bookings.
	•	Uses new useSlotDataForBars({bookings, daysInMonth, timeSlots, MAX_LANES}) to compute per-day layouts.
	•	Virtualizer stays the same: estimateSize: () => ROW_HEIGHT (fixed).
	•	Pass day-specific bars and occupancy to DayRow.

DayRow.tsx
	•	Renders Background Grid Layer (cells).
	•	Renders Bars Overlay Layer (thin bars with absolute positioning).
	•	Click on a cell: allowed only if occupancy[index] < MAX_LANES.
	•	Hover/long-press on a bar: show tooltip/hovercard with booking info.

useSlotDataForBars.ts (new or replace useSlotData)
	•	For each day:
	1.	Filter bookings to that day.
	2.	Map booking to [startIndex, endIndex) on timeSlots.
	3.	Lane assignment (greedy): try lane 0, if conflict then lane 1; if still conflict, drop or mark overflow.
	4.	Build occupancy[]: for each bar, increment all covered indices. Cap at MAX_LANES.
	5.	Return { bars, occupancy }.

status.tsx
	•	Returns visual style for bar color based on status (approved/wait/cancel).
	•	For bars: simple solid/gradient bg, small rounded corners, maybe border.

⸻

7) Core Algorithms

7.1) Index mapping (booking → slot indices)

Input: booking start/end Date (or ISO), array timeSlots: string[] like [“08:00”,“08:30”,…].
Output: { startIndex, endIndex } (end exclusive).

Rules (simple):
	•	Find the first index i where timeSlots[i] == start time string (e.g., “08:00”).
	•	Find the first index j where timeSlots[j] == end time string (e.g., “09:00”).
	•	Set startIndex = i, endIndex = j.
	•	If times fall between slots (e.g., 08:10), round to nearest fitting rule (choose a policy: floor/ceil). For now, assume slots align to 30m increments or your custom increments.

7.2) Lane Assignment (MAX_LANES = 2)

We want to avoid overlap inside the same lane.

Pseudocode:

function assignLanes(intervals /* sorted by startIndex */) {
  const lanesEnd: number[] = Array(MAX_LANES).fill(-Infinity);
  // lanesEnd[l] = endIndex of the last bar placed in lane l

  for (const iv of intervals) {
    let placed = false;
    for (let l = 0; l < MAX_LANES; l++) {
      if (iv.startIndex >= lanesEnd[l]) { // no conflict if new start >= last end
        iv.lane = l as 0 | 1;
        lanesEnd[l] = iv.endIndex;
        placed = true;
        break;
      }
    }
    if (!placed) {
      iv.lane = undefined; // overflow; we won’t render (or collect separately)
    }
  }

  return intervals.filter(iv => iv.lane !== undefined) as BarItem[];
}

Sort rule: sort intervals by startIndex (and maybe by end asc to pack tighter).

7.3) Occupancy Calculation

Pseudocode:

function buildOccupancy(bars: BarItem[], slotsCount: number) {
  const occ = Array(slotsCount).fill(0);
  for (const b of bars) {
    for (let i = b.startIndex; i < b.endIndex; i++) {
      occ[i] = Math.min(MAX_LANES, occ[i] + 1);
    }
  }
  return occ; // values 0..MAX_LANES
}

Usage: when rendering a cell at index, allow click if occ[index] < MAX_LANES.

⸻

8) Rendering Logic (DayRow)

8.1) Background Grid Layer
	•	Render each time cell as before.
	•	Class logic:
	•	If occ[i] >= MAX_LANES → add cursor-not-allowed and disable click.
	•	Else → cursor-pointer and open BookingForm on click.

8.2) Bars Overlay Layer
	•	Absolute container spanning the full width/height of the row.
	•	For each bar:
	•	left = DAY_LABEL_WIDTH + bar.startIndex * CELL_WIDTH
	•	width = (bar.endIndex - bar.startIndex) * CELL_WIDTH
	•	top = LANE_TOP_OFFSET + bar.lane * BAR_STACK_GAP
	•	height = BAR_HEIGHT
	•	Style color from status.tsx.
	•	Mouse events:
	•	onMouseEnter/onMouseLeave: show/hide tooltip.
	•	Mobile: onTouchStart (long-press) to show tooltip.

Z-index: Bars Overlay above Background Grid, but not full height (thin), so clicks around the bar still reach the grid.

⸻

9) Props Contracts

DayRow Props (update)

 type DayRowProps = {
   day: DayInfo;
   currentDate: Date;
   timeSlots: string[];
   bars: BarItem[];          // from hook for this day
   occupancy: number[];      // same length as timeSlots
   onSlotClick: (day: number, slot: string) => void;
   style: React.CSSProperties; // used by virtualizer
 };

useSlotDataForBars Signature

function useSlotDataForBars({
  bookings,
  daysInMonth,
  timeSlots,
  MAX_LANES,
}: {
  bookings: BookingData[];
  daysInMonth: DayInfo[];
  timeSlots: string[];
  MAX_LANES: number;
}): {
  barsByDay: Map<number /* dayIndex */, BarItem[]>;
  occupancyByDay: Map<number /* dayIndex */, number[]>;
};


⸻

10) Styling Rules (Bars)
	•	Rounded corners (e.g., rounded-sm)
	•	Height = BAR_HEIGHT
	•	Background color by status (approved/wait/cancelled)
	•	Optional thin border to help visibility
	•	No text inside (keep thin, clean)
	•	Tooltip shows on hover/press: name, room, start–end

⸻

11) Interaction Rules
	•	Click on Cell:
	•	If occupancy[i] < MAX_LANES → open BookingForm with that slot
	•	Else → do nothing (or show small hint “time full”)
	•	Hover/press Bar: show tooltip with booking details
	•	Keyboard: cells focusable? (optional) – future

⸻

12) Virtual Scroll
	•	Keep as-is: estimateSize: () => ROW_HEIGHT (60px).
	•	No change to useVirtualizer config.

⸻

13) Edge Cases & Policies
	•	More than 2 overlapping bookings on the same slot:
	•	Current policy: only first 2 are placed (by sort order). Others are overflow (not shown). The cell then becomes non-clickable.
	•	Optional: show a small +1 counter badge (future task).
	•	Bookings partially outside visible slots: clamp to edges (future if needed).
	•	Bookings not aligned to slot interval: pick a policy (floor/ceil). For now assume alignment to slots.

⸻

14) Test Checklist
	•	Overlap 0/1/2 bookings across same time → bars in lanes 0 and 1; 3rd booking not shown.
	•	Occupancy reaches 2 → cell not clickable.
	•	Bars span correct width across multiple slots.
	•	Tooltip shows on hover/press.
	•	Virtual scroll still smooth; row height constant.
	•	Different days independent (no leak of state across rows).

⸻

15) Implementation Order (Tasks for Cursor)
	1.	Add constants: constants.ts with MAX_LANES=2 and sizing values.
	2.	Types: add BarItem, DayBars to types/booking.ts.
	3.	Hook: create/modify useSlotDataForBars:
	•	Filter bookings by day
	•	Map to {startIndex,endIndex}
	•	Sort and run lane assignment (greedy)
	•	Build occupancy[]
	•	Return maps keyed by day index
	4.	DayRow:
	•	Render background grid cells as before; gate onClick by occupancy[i]
	•	Add Bars Overlay Layer; position bars using absolute math
	•	Add simple tooltip for bars
	5.	BookingCalendar:
	•	Import MAX_LANES and pass to hook
	•	Pass bars + occupancy to DayRow
	•	Keep virtualizer estimate size fixed
	6.	status.tsx: add bar color styles.
	7.	Manual tests using seeded data for overlaps.

⸻

16) Example Pseudocode (Hook)

// useSlotDataForBars.ts
export function useSlotDataForBars({ bookings, daysInMonth, timeSlots, MAX_LANES }) {
  return useMemo(() => {
    const barsByDay = new Map<number, BarItem[]>();
    const occupancyByDay = new Map<number, number[]>();

    daysInMonth.forEach((day, dayIdx) => {
      // 1) Get bookings for this day
      const dayBookings = bookings.filter(b => isSameLocalDay(b.timeStart, day.fullDate));

      // 2) Map to intervals
      const intervals = dayBookings.map(b => ({
        bookingId: b.bookingId,
        name: `${b.ownerName} ${b.ownerSurname}`,
        room: b.meetingRoom,
        status: b.bookingStatus,
        ...toIndices(b.timeStart, b.timeEnd, timeSlots), // returns {startIndex, endIndex}
      }));

      // Filter invalid
      const valid = intervals.filter(iv => iv.startIndex !== -1 && iv.endIndex !== -1 && iv.endIndex > iv.startIndex);

      // Sort by startIndex then endIndex
      valid.sort((a,b) => a.startIndex - b.startIndex || a.endIndex - b.endIndex);

      // 3) Assign lanes (0..MAX_LANES-1)
      const lanesEnd = Array(MAX_LANES).fill(-Infinity);
      const placed: BarItem[] = [];
      for (const iv of valid) {
        let laneUsed = -1;
        for (let l = 0; l < MAX_LANES; l++) {
          if (iv.startIndex >= lanesEnd[l]) { laneUsed = l; break; }
        }
        if (laneUsed >= 0) {
          placed.push({ ...iv, lane: laneUsed as 0|1 });
          lanesEnd[laneUsed] = iv.endIndex;
        } else {
          // overflow: ignore for now or collect in a separate list
        }
      }

      // 4) Build occupancy
      const occ = Array(timeSlots.length).fill(0);
      for (const bar of placed) {
        for (let i = bar.startIndex; i < bar.endIndex; i++) {
          occ[i] = Math.min(MAX_LANES, occ[i] + 1);
        }
      }

      barsByDay.set(dayIdx, placed);
      occupancyByDay.set(dayIdx, occ);
    });

    return { barsByDay, occupancyByDay };
  }, [bookings, daysInMonth, timeSlots, MAX_LANES]);
}


⸻

17) Example Pseudocode (DayRow)

// Inside DayRow render
<div className="rowContainer" style={{ position: 'relative', height: ROW_HEIGHT }}>
  {/* Background Grid Layer */}
  <div className="gridLayer">
    {timeSlots.map((slot, i) => (
      <div
        key={i}
        className={occupancy[i] >= MAX_LANES ? 'cell disabled' : 'cell clickable'}
        onClick={() => occupancy[i] < MAX_LANES && onSlotClick(day.date, slot)}
        title={occupancy[i] >= MAX_LANES ? 'Time full' : `Available: ${slot}`}
      />
    ))}
  </div>

  {/* Bars Overlay Layer */}
  <div className="barsOverlay" style={{ position: 'absolute', inset: 0 }}>
    {bars.map(bar => (
      <div
        key={bar.bookingId}
        className={`bar ${statusToClass(bar.status)}`}
        style={{
          position: 'absolute',
          left: DAY_LABEL_WIDTH + bar.startIndex * CELL_WIDTH,
          width: (bar.endIndex - bar.startIndex) * CELL_WIDTH,
          top: LANE_TOP_OFFSET + bar.lane * BAR_STACK_GAP,
          height: BAR_HEIGHT,
          borderRadius: 4,
        }}
        title={`${bar.name} • ${bar.room}`}
      />
    ))}
  </div>
</div>


⸻

This plan should be ready for Cursor to implement directly. Keep constants centralized and verify CSS widths match grid widths.